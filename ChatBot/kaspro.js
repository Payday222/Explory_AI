const OpenAI = require("openai");
const dotenv = require("dotenv");
const fs = require("fs");
const express = require('express');
const http = require('http');
const { Server } = require("socket.io");
const { Console } = require("console");
const redisAdapter = require('socket.io-redis');

dotenv.config();

// Initialize Express and HTTP server
const app = express();
const server = http.createServer(app);

// Initialize Socket.io
const io = new Server(server, {
  cors: {
    origin: "*", // Allow all origins during development
    methods: ["GET", "POST"],
  },
});


// io.adapter(redisAdapter({ host: 'localhost', port: 6379 }))
// Serve static files from the 'public' directory
app.use(express.static('public'));




// Initialize OpenAI API client
const openai = new OpenAI({
  apiKey: process.env.API_KEY,
});

// Store chat history
const chatHistory = new Map();
let context = new Map();
//let roomcode = "codecode";

// Handle socket connections
io.on('connection', (socket) => {
  console.log('Bot socket connected:', socket.id);
  socket.emit('testMessage', "Server is good");

  // Listen for 'SendData' events from clients
  socket.on('SendData', async (fullPrompt,contexting, roomCode) => {
    console.log('Prompt from client:', fullPrompt);
    context.set(roomCode,contexting);
    //! Lets see...
    console.log("roomcode: ", roomCode);

    await getChatCompletion(fullPrompt, socket, roomCode, socket.id);
  });
  
  socket.on('disconnect', () => {
    console.log(`User ${socket.id} disconnected, clearing history`);
    
  });
  // clear chat history on disconnect
  
  
//!  I am a bit scared about context not being sent correctly
  socket.on('sendAnswers', async (data) => {
    const {roomCode, answers} = data;
    console.log(`[Server] Received answers for room ${roomCode}: ${answers}`);
    console.log("clientID recieved: ", socket.id);
    
    let prompt = `Take the role of a teacher. For the test generated by you earlier, a student submitted the following answers: ${JSON.stringify(answers)}, 
    evaluate them. Provide the score and some feedback. Provide the person with materials to use and maybe some sources with this information: ${context.get(roomCode)}. 
    Begin your answer with "TEACHER@:" use the context as a base to provide him with materials. Do not ask me if I need something more or anything of sorts `;
    console.log('ClientID: ', socket.id); 
    console.log('Context pls work', context.get(roomCode))
  
    await getChatCompletion(prompt, socket, roomCode);
  });

  socket.on('generateFlashcards', async (test) => {
    console.log('Generating flashcards....');
    const prompt = `generate a set of flashcards for a student to study the topic of this here test ${test} The flascards should be created like so:
    "SIDE1 
    data
    SIDE2
    data
    Do not provide any other information, and please strictly stick to the requested format of flashcards. Begin your response with FLASHCARDS"`;
    await GenerateFlashcards(prompt);
    
  });
});



async function getChatCompletion(prompt, socket, roomCode, socketID) {

  setTimeout(() => {
    const rooms = io.sockets.adapter.rooms;
    const sids = io.sockets.adapter.sids;

    console.log('--- Room Overview ---');

    for (let [roomName, socketSet] of rooms) {
        // Skip rooms that are just individual socket IDs
        if (!sids.has(roomName)) {
            console.log(`Room: ${roomName}`);
            console.log('Sockets:', [...socketSet]);
            console.log('--------------------');
        }
    }
}, 500);

  console.log("roomcode getChatCompletion:", roomCode);
  const SingularHistory = chatHistory.get(roomCode) || [];


  const messages = SingularHistory.map(([role, content]) => ({
    role,
    content,
  }));
  //roomCode = roomCode;
   
  messages.push({ role: 'user', content: prompt });
 
  console.log('Messages sent to OpenAI:', messages);

  try {
    const chatCompletion = await openai.chat.completions.create({
      messages: messages,
      model: "gpt-4", 
    });



    const response = chatCompletion.choices[0].message.content;
    console.log('Response from OpenAI:', response);

    const splitToken = "HUBERCIKLUBCHLOPCOW";
    const tokenIndex = response.indexOf(splitToken);
    let clientResponse = "";
    let hostResponse = "";
   
    if (response.includes("TEACHER@:")) {
      // Emit the response along with the clientID so that the relay knows where to send it.
      const clientIDs = socket.id;
      //!  socket.emit('EvaluationResponse', { response, clientIDs }); - maybe change back
      io.to(clientIDs).emit('EvaluationResponse', { response }); //? this should be better
      console.log('Emitted EvaluationResponse for clientID:', clientIDs);
    }
    else 
    {
      if (tokenIndex !== -1) {
        clientResponse = response.substring(0, tokenIndex).trim();
        hostResponse = response.substring(tokenIndex + splitToken.length).trim();
      } else {
        clientResponse = response;
      } 
  
      if(true) {
        console.log("roomcode before emit: ", roomCode);
        socket.join(roomCode);
        socket.broadcast.to(roomCode).emit('botResponseClient', clientResponse);
        console.log('emmiting to ', socketID);
        io.emit('botResponseClient', clientResponse);
      } else {
        console.log("roomcode: ", roomCode);
        console.log("Room doesnt exist");
      }
      socket.emit('botResponseHost', hostResponse);
      console.log('emmiting host and client botresponse', clientResponse, hostResponse);
    }

    if (tokenIndex !== -1) {
      clientResponse = response.substring(0, tokenIndex).trim();
      hostResponse = response.substring(tokenIndex + splitToken.length).trim();
    } else {
      clientResponse = response;
    } 
    if(io.sockets.adapter.rooms.has(roomCode)) {
    io.to(roomCode).emit('botResponseClient', clientResponse);
    console.log('Room exists, emmitted succesfully');
    } else {
    
      console.log("Room doesnt exist");

    }

    io.emit('botResponseClientv2', {clientResponse, roomCode});
    //use socket.to(roomcode) instead of io.emit
    //send the roomcode with the test data and pass it along to getchatcompletion 
    
    
    SingularHistory.push(['user', prompt]);
    SingularHistory.push(['assistant', response]);
    chatHistory.set(roomCode,SingularHistory);
    

  } catch (error) {
    console.error('Error generating AI response:', error);
    socket.to(roomCode).emit('botResponseClient', "Error: Unable to get response from AI.");
    
  }

  socket.on('cleanUpRoomData', (oldRoomCode) => {
    console.log(`Cleaning up data for room: ${oldRoomCode}`);
    
    context.delete(oldRoomCode);
    chatHistory.delete(oldRoomCode);
});

}

async function GenerateFlashcards(prompt) {

  try {
    const generated = await openai.chat.completions.create({
      model: "gpt-4", 
      messages: [{ role: "user", content: prompt }]

    });
    const response = generated.choices[0].message.content;



    let cards = [];
    let chunks = response.split('SIDE1').slice(1);

    for(const chunk of chunks) {
      const [side1, side2] = chunk.split("SIDE2").map(str => str.trim());
      if(side1 && side2) {
        cards.push([side1, side2]);
      }
    }
    console.log("flashcards: ", cards);
  } catch(error) {
    console.log("eror generating flashcards: ", error);
  }






}



// Start the server
server.listen(3007, () => {
  console.log("Bot server running on port 3007");
});